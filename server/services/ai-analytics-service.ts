import { 
  users, 
  guestProgressTracking,
  sessions,
  homeworkAssignments,
  quizScores,
  type User,
  type Session,
  type HomeworkAssignment,
  type QuizScore
} from "@shared/schema";
import { db } from "../db";
import { eq, and, desc, asc, sql, gte, lte, inArray } from "drizzle-orm";

export interface LearningProblem {
  id: string;
  userId: number;
  type: 'skill_weakness' | 'engagement_drop' | 'difficulty_spike' | 'learning_plateau' | 'attendance_pattern' | 'homework_struggle';
  severity: 'low' | 'medium' | 'high' | 'critical';
  title: string;
  description: string;
  detectedAt: Date;
  affectedSkills: string[];
  confidence: number; // 0-100
  evidence: string[];
  recommendations: LearningRecommendation[];
  estimatedImpact: string;
  autoGenerated: boolean;
}

export interface LearningRecommendation {
  id: string;
  type: 'study_plan' | 'resource' | 'skill_focus' | 'schedule_change' | 'teaching_method' | 'practice_activity';
  priority: 'low' | 'medium' | 'high';
  title: string;
  description: string;
  actionSteps: string[];
  estimatedTimeWeeks: number;
  expectedOutcome: string;
  resourceLinks?: string[];
}

export interface SkillCorrelation {
  skill1: string;
  skill2: string;
  correlationStrength: number; // -1 to 1
  correlationType: 'positive' | 'negative' | 'neutral';
  significance: number; // 0-100
  studentCount: number;
  averageImpact: number;
}

export interface PerformancePattern {
  userId: number;
  patternType: 'improving' | 'declining' | 'stable' | 'volatile' | 'plateaued';
  skill: string;
  trendDirection: number; // -1 to 1
  volatility: number; // 0-1
  lastChangeDetected: Date;
  predictionConfidence: number;
  futureOutlook: 'positive' | 'negative' | 'neutral';
}

export class AIAnalyticsService {
  constructor() {
    // AI Analytics service with built-in analytics functionality
  }

  // ====================================================================
  // AI-POWERED LEARNING PROBLEM DETECTION
  // ====================================================================

  /**
   * Analyze student performance and detect learning problems using AI algorithms
   */
  async detectLearningProblems(userId: number, timeframeDays: number = 30): Promise<LearningProblem[]> {
    try {
      const problems: LearningProblem[] = [];
      
      // Get student performance data
      const performanceData = await this.getStudentPerformanceData(userId, timeframeDays);
      
      if (!performanceData) {
        return [];
      }

      // Problem Detection Algorithms
      
      // 1. Skill Weakness Detection
      const skillWeaknesses = await this.detectSkillWeaknesses(performanceData);
      problems.push(...skillWeaknesses);

      // 2. Engagement Drop Detection  
      const engagementIssues = await this.detectEngagementDrop(performanceData);
      problems.push(...engagementIssues);

      // 3. Learning Plateau Detection
      const plateauIssues = await this.detectLearningPlateau(performanceData);
      problems.push(...plateauIssues);

      // 4. Homework Struggle Detection
      const homeworkIssues = await this.detectHomeworkStruggles(performanceData);
      problems.push(...homeworkIssues);

      // 5. Attendance Pattern Issues
      const attendanceIssues = await this.detectAttendancePatterns(performanceData);
      problems.push(...attendanceIssues);

      // Sort by severity and confidence
      return problems.sort((a, b) => {
        const severityOrder = { 'critical': 4, 'high': 3, 'medium': 2, 'low': 1 };
        const severityDiff = severityOrder[b.severity] - severityOrder[a.severity];
        if (severityDiff !== 0) return severityDiff;
        return b.confidence - a.confidence;
      });

    } catch (error) {
      console.error('Error detecting learning problems:', error);
      return [];
    }
  }

  /**
   * Detect skill weaknesses using performance correlation analysis
   */
  private async detectSkillWeaknesses(data: any): Promise<LearningProblem[]> {
    const problems: LearningProblem[] = [];
    
    // Analyze quiz scores across different skills
    const skillAverages = this.calculateSkillAverages(data.quizScores);
    const overallAverage = Object.values(skillAverages).reduce((a: number, b: number) => a + b, 0) / Object.keys(skillAverages).length;
    
    for (const [skill, average] of Object.entries(skillAverages)) {
      const averageNum = average as number;
      
      // If skill is significantly below overall average
      if (averageNum < overallAverage - 15) {
        const confidence = Math.min(95, (overallAverage - averageNum) * 2);
        
        problems.push({
          id: `skill_weakness_${skill}_${data.userId}`,
          userId: data.userId,
          type: 'skill_weakness',
          severity: averageNum < overallAverage - 25 ? 'high' : 'medium',
          title: `${skill} Performance Below Expected Level`,
          description: `Student is underperforming in ${skill} with average score of ${averageNum}% compared to overall average of ${overallAverage}%.`,
          detectedAt: new Date(),
          affectedSkills: [skill],
          confidence,
          evidence: [
            `${skill} average: ${averageNum}%`,
            `Overall average: ${overallAverage}%`,
            `Performance gap: ${(overallAverage - averageNum).toFixed(1)}%`
          ],
          recommendations: await this.generateSkillImprovementRecommendations(skill, averageNum),
          estimatedImpact: 'Addressing this weakness could improve overall performance by 10-15%',
          autoGenerated: true
        });
      }
    }
    
    return problems;
  }

  /**
   * Detect engagement drops using session frequency and duration analysis
   */
  private async detectEngagementDrop(data: any): Promise<LearningProblem[]> {
    const problems: LearningProblem[] = [];
    
    const sessions = data.sessions;
    if (sessions.length < 5) return problems; // Need minimum data
    
    // Calculate engagement trends
    const recentSessions = sessions.slice(-7); // Last 7 sessions
    const earlierSessions = sessions.slice(-14, -7); // Previous 7 sessions
    
    const recentAvgDuration = recentSessions.reduce((a: any, s: any) => a + (s.actualDurationMinutes || 0), 0) / recentSessions.length;
    const earlierAvgDuration = earlierSessions.reduce((a: any, s: any) => a + (s.actualDurationMinutes || 0), 0) / earlierSessions.length;
    
    const durationDrop = ((earlierAvgDuration - recentAvgDuration) / earlierAvgDuration) * 100;
    
    if (durationDrop > 25) { // 25% drop in session duration
      problems.push({
        id: `engagement_drop_${data.userId}`,
        userId: data.userId,
        type: 'engagement_drop',
        severity: durationDrop > 50 ? 'high' : 'medium',
        title: 'Declining Student Engagement Detected',
        description: `Session duration has dropped by ${durationDrop.toFixed(1)}% in recent sessions, indicating potential engagement issues.`,
        detectedAt: new Date(),
        affectedSkills: ['engagement', 'motivation'],
        confidence: Math.min(90, durationDrop * 1.5),
        evidence: [
          `Recent avg duration: ${recentAvgDuration.toFixed(1)} minutes`,
          `Previous avg duration: ${earlierAvgDuration.toFixed(1)} minutes`,
          `Duration drop: ${durationDrop.toFixed(1)}%`
        ],
        recommendations: await this.generateEngagementRecommendations(durationDrop),
        estimatedImpact: 'Improving engagement could increase learning effectiveness by 20-30%',
        autoGenerated: true
      });
    }
    
    return problems;
  }

  /**
   * Detect learning plateaus using progress trend analysis
   */
  private async detectLearningPlateau(data: any): Promise<LearningProblem[]> {
    const problems: LearningProblem[] = [];
    
    const quizScores = data.quizScores;
    if (quizScores.length < 8) return problems;
    
    // Calculate rolling averages to detect plateaus
    const recentScores = quizScores.slice(-8).map((q: any) => q.score);
    const trend = this.calculateTrend(recentScores);
    const volatility = this.calculateVolatility(recentScores);
    
    // Plateau detected: low trend + low volatility + reasonable number of data points
    if (Math.abs(trend) < 2 && volatility < 5 && recentScores.length >= 6) {
      const avgScore = recentScores.reduce((a: number, b: number) => a + b, 0) / recentScores.length;
      
      problems.push({
        id: `learning_plateau_${data.userId}`,
        userId: data.userId,
        type: 'learning_plateau',
        severity: avgScore < 70 ? 'high' : 'medium',
        title: 'Learning Plateau Identified',
        description: `Student progress has stagnated with minimal improvement over recent sessions (${trend.toFixed(1)}% trend).`,
        detectedAt: new Date(),
        affectedSkills: ['overall_progress'],
        confidence: 85,
        evidence: [
          `Recent trend: ${trend.toFixed(1)}%`,
          `Score volatility: ${volatility.toFixed(1)}%`,
          `Average recent score: ${avgScore.toFixed(1)}%`
        ],
        recommendations: await this.generatePlateauBreakingRecommendations(avgScore),
        estimatedImpact: 'Breaking this plateau could resume 5-10% monthly improvement',
        autoGenerated: true
      });
    }
    
    return problems;
  }

  /**
   * Detect homework completion and performance issues
   */
  private async detectHomeworkStruggles(data: any): Promise<LearningProblem[]> {
    const problems: LearningProblem[] = [];
    
    const homework = data.homework;
    if (homework.length < 5) return problems;
    
    const recentHomework = homework.slice(-10);
    const completionRate = recentHomework.filter((h: any) => h.submittedAt).length / recentHomework.length;
    const avgScore = recentHomework
      .filter((h: any) => h.score !== null)
      .reduce((a: any, h: any) => a + h.score, 0) / recentHomework.filter((h: any) => h.score !== null).length;
    
    if (completionRate < 0.7 || avgScore < 60) {
      problems.push({
        id: `homework_struggle_${data.userId}`,
        userId: data.userId,
        type: 'homework_struggle',
        severity: completionRate < 0.5 || avgScore < 50 ? 'high' : 'medium',
        title: 'Homework Performance Issues',
        description: `Student showing difficulties with homework: ${(completionRate * 100).toFixed(1)}% completion rate, ${avgScore.toFixed(1)}% average score.`,
        detectedAt: new Date(),
        affectedSkills: ['self_study', 'time_management'],
        confidence: 80,
        evidence: [
          `Completion rate: ${(completionRate * 100).toFixed(1)}%`,
          `Average score: ${avgScore.toFixed(1)}%`,
          `Recent assignments: ${recentHomework.length}`
        ],
        recommendations: await this.generateHomeworkSupportRecommendations(completionRate, avgScore),
        estimatedImpact: 'Improving homework habits could boost overall performance by 15-20%',
        autoGenerated: true
      });
    }
    
    return problems;
  }

  /**
   * Detect attendance pattern issues
   */
  private async detectAttendancePatterns(data: any): Promise<LearningProblem[]> {
    const problems: LearningProblem[] = [];
    
    const sessions = data.sessions;
    if (sessions.length < 8) return problems;
    
    const recentSessions = sessions.slice(-12);
    const attendanceRate = recentSessions.filter((s: any) => s.status === 'completed').length / recentSessions.length;
    
    // Check for irregular patterns
    const missedConsecutive = this.findMaxConsecutiveMissedSessions(recentSessions);
    
    if (attendanceRate < 0.8 || missedConsecutive >= 3) {
      problems.push({
        id: `attendance_pattern_${data.userId}`,
        userId: data.userId,
        type: 'attendance_pattern',
        severity: attendanceRate < 0.6 || missedConsecutive >= 5 ? 'critical' : 'high',
        title: 'Attendance Pattern Concerns',
        description: `Irregular attendance detected: ${(attendanceRate * 100).toFixed(1)}% attendance rate with ${missedConsecutive} consecutive missed sessions.`,
        detectedAt: new Date(),
        affectedSkills: ['consistency', 'engagement'],
        confidence: 90,
        evidence: [
          `Attendance rate: ${(attendanceRate * 100).toFixed(1)}%`,
          `Max consecutive absences: ${missedConsecutive}`,
          `Recent sessions analyzed: ${recentSessions.length}`
        ],
        recommendations: await this.generateAttendanceRecommendations(attendanceRate, missedConsecutive),
        estimatedImpact: 'Improving attendance could significantly boost learning outcomes',
        autoGenerated: true
      });
    }
    
    return problems;
  }

  // ====================================================================
  // CROSS-SKILL PERFORMANCE CORRELATIONS
  // ====================================================================

  /**
   * Analyze correlations between different language skills
   */
  async analyzeSkillCorrelations(userIds?: number[]): Promise<SkillCorrelation[]> {
    try {
      // Get performance data for correlation analysis
      const correlationData = await this.getSkillCorrelationData(userIds);
      
      const skills = ['speaking', 'listening', 'reading', 'writing', 'grammar', 'vocabulary'];
      const correlations: SkillCorrelation[] = [];
      
      // Calculate correlations between all skill pairs
      for (let i = 0; i < skills.length; i++) {
        for (let j = i + 1; j < skills.length; j++) {
          const skill1 = skills[i];
          const skill2 = skills[j];
          
          const correlation = this.calculateSkillCorrelation(correlationData, skill1, skill2);
          
          if (correlation) {
            correlations.push(correlation);
          }
        }
      }
      
      return correlations.sort((a, b) => Math.abs(b.correlationStrength) - Math.abs(a.correlationStrength));
      
    } catch (error) {
      console.error('Error analyzing skill correlations:', error);
      return [];
    }
  }

  /**
   * Calculate correlation coefficient between two skills
   */
  private calculateSkillCorrelation(data: any[], skill1: string, skill2: string): SkillCorrelation | null {
    const validPairs = data
      .map(student => ({
        skill1Score: this.getSkillAverage(student.scores, skill1),
        skill2Score: this.getSkillAverage(student.scores, skill2)
      }))
      .filter(pair => pair.skill1Score !== null && pair.skill2Score !== null);
    
    if (validPairs.length < 10) return null; // Need minimum sample size
    
    const correlation = this.pearsonCorrelation(
      validPairs.map(p => p.skill1Score!),
      validPairs.map(p => p.skill2Score!)
    );
    
    const significance = this.calculateSignificance(correlation, validPairs.length);
    
    return {
      skill1,
      skill2,
      correlationStrength: correlation,
      correlationType: correlation > 0.1 ? 'positive' : correlation < -0.1 ? 'negative' : 'neutral',
      significance,
      studentCount: validPairs.length,
      averageImpact: Math.abs(correlation) * 100
    };
  }

  // ====================================================================
  // PERFORMANCE PATTERN ANALYSIS
  // ====================================================================

  /**
   * Analyze individual student performance patterns
   */
  async analyzePerformancePatterns(userId: number): Promise<PerformancePattern[]> {
    try {
      const performanceData = await this.getStudentPerformanceData(userId, 90); // 90 days
      if (!performanceData) return [];
      
      const skills = ['speaking', 'listening', 'reading', 'writing', 'grammar', 'vocabulary'];
      const patterns: PerformancePattern[] = [];
      
      for (const skill of skills) {
        const skillScores = this.getSkillScores(performanceData.quizScores, skill);
        if (skillScores.length < 5) continue;
        
        const pattern = this.analyzeSkillPattern(userId, skill, skillScores);
        if (pattern) {
          patterns.push(pattern);
        }
      }
      
      return patterns;
      
    } catch (error) {
      console.error('Error analyzing performance patterns:', error);
      return [];
    }
  }

  /**
   * Analyze pattern for a specific skill
   */
  private analyzeSkillPattern(userId: number, skill: string, scores: number[]): PerformancePattern | null {
    if (scores.length < 5) return null;
    
    const trend = this.calculateTrend(scores);
    const volatility = this.calculateVolatility(scores);
    
    // Determine pattern type
    let patternType: PerformancePattern['patternType'];
    if (trend > 5) patternType = 'improving';
    else if (trend < -5) patternType = 'declining';
    else if (volatility > 15) patternType = 'volatile';
    else if (Math.abs(trend) < 2 && volatility < 5) patternType = 'plateaued';
    else patternType = 'stable';
    
    // Calculate prediction confidence
    const predictionConfidence = Math.max(50, 100 - volatility * 2);
    
    // Determine future outlook
    let futureOutlook: PerformancePattern['futureOutlook'];
    if (patternType === 'improving' || (patternType === 'stable' && trend > 0)) {
      futureOutlook = 'positive';
    } else if (patternType === 'declining') {
      futureOutlook = 'negative';
    } else {
      futureOutlook = 'neutral';
    }
    
    return {
      userId,
      patternType,
      skill,
      trendDirection: trend / 100,
      volatility: volatility / 100,
      lastChangeDetected: new Date(),
      predictionConfidence,
      futureOutlook
    };
  }

  // ====================================================================
  // HELPER METHODS
  // ====================================================================

  /**
   * Get comprehensive student performance data
   */
  private async getStudentPerformanceData(userId: number, timeframeDays: number) {
    const startDate = new Date();
    startDate.setDate(startDate.getDate() - timeframeDays);
    
    try {
      const [user, sessionData, quizData, homeworkData] = await Promise.all([
        db.select().from(users).where(eq(users.id, userId)).limit(1),
        db.select().from(sessions)
          .where(and(
            eq(sessions.studentId, userId),
            gte(sessions.sessionDate, startDate)
          ))
          .orderBy(asc(sessions.sessionDate)),
        db.select().from(quizScores)
          .where(and(
            eq(quizScores.studentId, userId),
            gte(quizScores.createdAt, startDate)
          ))
          .orderBy(asc(quizScores.createdAt)),
        db.select().from(homeworkAssignments)
          .where(and(
            eq(homeworkAssignments.studentId, userId),
            gte(homeworkAssignments.createdAt, startDate)
          ))
          .orderBy(asc(homeworkAssignments.createdAt))
      ]);
      
      if (user.length === 0) return null;
      
      return {
        userId,
        user: user[0],
        sessions: sessionData,
        quizScores: quizData,
        homework: homeworkData
      };
      
    } catch (error) {
      console.error('Error fetching student performance data:', error);
      return null;
    }
  }

  /**
   * Calculate skill averages from quiz scores
   */
  private calculateSkillAverages(quizScores: any[]): Record<string, number> {
    const skillScores: Record<string, number[]> = {};
    
    quizScores.forEach(quiz => {
      const skill = quiz.skillCategory || 'general';
      if (!skillScores[skill]) skillScores[skill] = [];
      skillScores[skill].push(quiz.score);
    });
    
    const averages: Record<string, number> = {};
    Object.keys(skillScores).forEach(skill => {
      const scores = skillScores[skill];
      averages[skill] = scores.reduce((a, b) => a + b, 0) / scores.length;
    });
    
    return averages;
  }

  /**
   * Calculate trend using linear regression
   */
  private calculateTrend(values: number[]): number {
    if (values.length < 2) return 0;
    
    const n = values.length;
    const indices = Array.from({length: n}, (_, i) => i);
    
    const sumX = indices.reduce((a, b) => a + b, 0);
    const sumY = values.reduce((a, b) => a + b, 0);
    const sumXY = indices.reduce((sum, x, i) => sum + x * values[i], 0);
    const sumXX = indices.reduce((sum, x) => sum + x * x, 0);
    
    const slope = (n * sumXY - sumX * sumY) / (n * sumXX - sumX * sumX);
    
    // Convert slope to percentage change per period
    return slope * (100 / (sumY / n));
  }

  /**
   * Calculate volatility (standard deviation as percentage of mean)
   */
  private calculateVolatility(values: number[]): number {
    if (values.length < 2) return 0;
    
    const mean = values.reduce((a, b) => a + b, 0) / values.length;
    const variance = values.reduce((sum, val) => sum + Math.pow(val - mean, 2), 0) / values.length;
    const stdDev = Math.sqrt(variance);
    
    return (stdDev / mean) * 100;
  }

  /**
   * Calculate Pearson correlation coefficient
   */
  private pearsonCorrelation(x: number[], y: number[]): number {
    const n = x.length;
    if (n !== y.length || n === 0) return 0;
    
    const sumX = x.reduce((a, b) => a + b, 0);
    const sumY = y.reduce((a, b) => a + b, 0);
    const sumXY = x.reduce((sum, xi, i) => sum + xi * y[i], 0);
    const sumXX = x.reduce((sum, xi) => sum + xi * xi, 0);
    const sumYY = y.reduce((sum, yi) => sum + yi * yi, 0);
    
    const numerator = n * sumXY - sumX * sumY;
    const denominator = Math.sqrt((n * sumXX - sumX * sumX) * (n * sumYY - sumY * sumY));
    
    return denominator === 0 ? 0 : numerator / denominator;
  }

  /**
   * Generate skill improvement recommendations
   */
  private async generateSkillImprovementRecommendations(skill: string, currentScore: number): Promise<LearningRecommendation[]> {
    const recommendations: LearningRecommendation[] = [];
    
    if (skill === 'speaking') {
      recommendations.push({
        id: `speaking_improvement_${Date.now()}`,
        type: 'practice_activity',
        priority: 'high',
        title: 'Daily Speaking Practice',
        description: 'Increase speaking practice with structured conversation exercises',
        actionSteps: [
          'Practice 15 minutes of speaking daily',
          'Record yourself and review pronunciation',
          'Join conversation practice sessions',
          'Use speaking apps with AI feedback'
        ],
        estimatedTimeWeeks: 4,
        expectedOutcome: 'Improve speaking confidence and fluency by 20-25%',
        resourceLinks: ['/resources/speaking-practice', '/apps/pronunciation-trainer']
      });
    }
    
    // Add more skill-specific recommendations...
    
    return recommendations;
  }

  /**
   * Generate engagement improvement recommendations
   */
  private async generateEngagementRecommendations(dropPercentage: number): Promise<LearningRecommendation[]> {
    return [
      {
        id: `engagement_improvement_${Date.now()}`,
        type: 'teaching_method',
        priority: 'high',
        title: 'Gamification and Interactive Content',
        description: 'Introduce more interactive and gamified learning elements',
        actionSteps: [
          'Add achievement badges and progress tracking',
          'Implement interactive quizzes and games',
          'Create personal learning challenges',
          'Introduce peer competition elements'
        ],
        estimatedTimeWeeks: 2,
        expectedOutcome: 'Increase engagement and session duration by 30-40%'
      }
    ];
  }

  /**
   * Generate plateau breaking recommendations
   */
  private async generatePlateauBreakingRecommendations(currentScore: number): Promise<LearningRecommendation[]> {
    return [
      {
        id: `plateau_breaking_${Date.now()}`,
        type: 'study_plan',
        priority: 'high',
        title: 'Advanced Challenge Program',
        description: 'Introduce advanced materials and new learning methods',
        actionSteps: [
          'Increase lesson difficulty by one level',
          'Add real-world application exercises',
          'Introduce new learning formats (videos, podcasts)',
          'Set higher performance targets'
        ],
        estimatedTimeWeeks: 3,
        expectedOutcome: 'Resume 5-10% monthly improvement and break learning plateau'
      }
    ];
  }

  /**
   * Generate homework support recommendations
   */
  private async generateHomeworkSupportRecommendations(completionRate: number, avgScore: number): Promise<LearningRecommendation[]> {
    return [
      {
        id: `homework_support_${Date.now()}`,
        type: 'study_plan',
        priority: 'high',
        title: 'Homework Success Strategy',
        description: 'Structured approach to improve homework completion and quality',
        actionSteps: [
          'Create a consistent homework schedule',
          'Break assignments into smaller tasks',
          'Provide additional support resources',
          'Implement progress check-ins'
        ],
        estimatedTimeWeeks: 2,
        expectedOutcome: 'Improve homework completion to 85%+ and average score by 15-20%'
      }
    ];
  }

  /**
   * Generate attendance improvement recommendations
   */
  private async generateAttendanceRecommendations(attendanceRate: number, missedConsecutive: number): Promise<LearningRecommendation[]> {
    return [
      {
        id: `attendance_improvement_${Date.now()}`,
        type: 'schedule_change',
        priority: 'critical',
        title: 'Attendance Recovery Plan',
        description: 'Systematic approach to improve class attendance',
        actionSteps: [
          'Review and adjust class schedule if needed',
          'Implement attendance tracking with reminders',
          'Provide makeup session opportunities',
          'Address underlying attendance barriers'
        ],
        estimatedTimeWeeks: 1,
        expectedOutcome: 'Increase attendance to 90%+ and eliminate extended absences'
      }
    ];
  }

  // Additional helper methods...
  private getSkillCorrelationData = async (userIds?: number[]) => [];
  private getSkillAverage = (scores: any[], skill: string) => null;
  private calculateSignificance = (correlation: number, sampleSize: number) => 0;
  private getSkillScores = (quizScores: any[], skill: string) => [];
  private findMaxConsecutiveMissedSessions = (sessions: any[]) => 0;
}

export const aiAnalyticsService = new AIAnalyticsService();