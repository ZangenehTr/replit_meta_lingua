import { Router } from "express";
import { z } from "zod";
import { aiAnalyticsService } from "../services/ai-analytics-service";
import { 
  learningProblems, 
  learningRecommendations,
  skillCorrelations,
  performancePatterns,
  analyticsInsights,
  insertLearningProblemSchema,
  insertLearningRecommendationSchema
} from "@shared/schema";
import { db } from "../db";
import { eq, and, desc, gte, lte } from "drizzle-orm";

const enhancedAnalyticsRouter = Router();

// ====================================================================
// AI-POWERED LEARNING PROBLEM DETECTION
// ====================================================================

/**
 * GET /api/analytics/problems/:userId
 * Get detected learning problems for a specific student
 */
enhancedAnalyticsRouter.get("/problems/:userId", async (req, res) => {
  try {
    const userId = parseInt(req.params.userId);
    const timeframeDays = parseInt(req.query.timeframe as string) || 30;
    
    if (isNaN(userId)) {
      return res.status(400).json({ 
        success: false, 
        error: "Invalid user ID" 
      });
    }

    // Get AI-detected problems
    const detectedProblems = await aiAnalyticsService.detectLearningProblems(userId, timeframeDays);
    
    // Get existing problems from database
    const existingProblems = await db
      .select()
      .from(learningProblems)
      .where(and(
        eq(learningProblems.userId, userId),
        eq(learningProblems.status, 'active')
      ))
      .orderBy(desc(learningProblems.detectedAt));

    // Combine AI-detected with stored problems, avoiding duplicates
    const allProblems = [...detectedProblems];
    
    for (const existing of existingProblems) {
      if (!detectedProblems.find(p => p.type === existing.type && p.title === existing.title)) {
        allProblems.push({
          id: existing.id.toString(),
          userId: existing.userId,
          type: existing.type as any,
          severity: existing.severity as any,
          title: existing.title,
          description: existing.description,
          detectedAt: existing.detectedAt || new Date(),
          affectedSkills: existing.affectedSkills || [],
          confidence: existing.confidence,
          evidence: existing.evidence || [],
          recommendations: [], // Load separately if needed
          estimatedImpact: existing.estimatedImpact || '',
          autoGenerated: existing.autoGenerated
        });
      }
    }

    res.json({
      success: true,
      problems: allProblems,
      summary: {
        total: allProblems.length,
        critical: allProblems.filter(p => p.severity === 'critical').length,
        high: allProblems.filter(p => p.severity === 'high').length,
        medium: allProblems.filter(p => p.severity === 'medium').length,
        low: allProblems.filter(p => p.severity === 'low').length
      }
    });

  } catch (error) {
    console.error('Error getting learning problems:', error);
    res.status(500).json({ 
      success: false, 
      error: "Failed to get learning problems" 
    });
  }
});

/**
 * POST /api/analytics/problems
 * Store a detected learning problem
 */
enhancedAnalyticsRouter.post("/problems", async (req, res) => {
  try {
    const problemData = insertLearningProblemSchema.parse(req.body);
    
    const [problem] = await db
      .insert(learningProblems)
      .values(problemData)
      .returning();

    res.json({
      success: true,
      problem
    });

  } catch (error) {
    console.error('Error storing learning problem:', error);
    res.status(500).json({ 
      success: false, 
      error: "Failed to store learning problem" 
    });
  }
});

/**
 * PUT /api/analytics/problems/:problemId/resolve
 * Mark a learning problem as resolved
 */
enhancedAnalyticsRouter.put("/problems/:problemId/resolve", async (req, res) => {
  try {
    const problemId = parseInt(req.params.problemId);
    
    const [updatedProblem] = await db
      .update(learningProblems)
      .set({
        status: 'resolved',
        resolvedAt: new Date(),
        updatedAt: new Date()
      })
      .where(eq(learningProblems.id, problemId))
      .returning();

    res.json({
      success: true,
      problem: updatedProblem
    });

  } catch (error) {
    console.error('Error resolving learning problem:', error);
    res.status(500).json({ 
      success: false, 
      error: "Failed to resolve learning problem" 
    });
  }
});

// ====================================================================
// LEARNING RECOMMENDATIONS
// ====================================================================

/**
 * GET /api/analytics/recommendations/:userId
 * Get personalized learning recommendations for a student
 */
enhancedAnalyticsRouter.get("/recommendations/:userId", async (req, res) => {
  try {
    const userId = parseInt(req.params.userId);
    
    if (isNaN(userId)) {
      return res.status(400).json({ 
        success: false, 
        error: "Invalid user ID" 
      });
    }

    const recommendations = await db
      .select()
      .from(learningRecommendations)
      .where(and(
        eq(learningRecommendations.userId, userId),
        eq(learningRecommendations.status, 'pending')
      ))
      .orderBy(desc(learningRecommendations.createdAt));

    res.json({
      success: true,
      recommendations
    });

  } catch (error) {
    console.error('Error getting recommendations:', error);
    res.status(500).json({ 
      success: false, 
      error: "Failed to get recommendations" 
    });
  }
});

/**
 * POST /api/analytics/recommendations
 * Create a new learning recommendation
 */
enhancedAnalyticsRouter.post("/recommendations", async (req, res) => {
  try {
    const recommendationData = insertLearningRecommendationSchema.parse(req.body);
    
    const [recommendation] = await db
      .insert(learningRecommendations)
      .values(recommendationData)
      .returning();

    res.json({
      success: true,
      recommendation
    });

  } catch (error) {
    console.error('Error creating recommendation:', error);
    res.status(500).json({ 
      success: false, 
      error: "Failed to create recommendation" 
    });
  }
});

/**
 * PUT /api/analytics/recommendations/:recommendationId/implement
 * Mark a recommendation as being implemented
 */
enhancedAnalyticsRouter.put("/recommendations/:recommendationId/implement", async (req, res) => {
  try {
    const recommendationId = parseInt(req.params.recommendationId);
    
    const [updatedRecommendation] = await db
      .update(learningRecommendations)
      .set({
        status: 'in_progress',
        implementedAt: new Date(),
        updatedAt: new Date()
      })
      .where(eq(learningRecommendations.id, recommendationId))
      .returning();

    res.json({
      success: true,
      recommendation: updatedRecommendation
    });

  } catch (error) {
    console.error('Error implementing recommendation:', error);
    res.status(500).json({ 
      success: false, 
      error: "Failed to implement recommendation" 
    });
  }
});

// ====================================================================
// SKILL CORRELATIONS
// ====================================================================

/**
 * GET /api/analytics/skill-correlations
 * Get cross-skill performance correlations
 */
enhancedAnalyticsRouter.get("/skill-correlations", async (req, res) => {
  try {
    const userIds = req.query.userIds ? 
      (req.query.userIds as string).split(',').map(id => parseInt(id)) : 
      undefined;

    // Get AI-analyzed correlations
    const correlations = await aiAnalyticsService.analyzeSkillCorrelations(userIds);
    
    // Get stored correlations from database
    const storedCorrelations = await db
      .select()
      .from(skillCorrelations)
      .orderBy(desc(skillCorrelations.analysisDate))
      .limit(50);

    // Combine and deduplicate
    const allCorrelations = [...correlations];
    
    for (const stored of storedCorrelations) {
      const exists = correlations.find(c => 
        (c.skill1 === stored.skill1 && c.skill2 === stored.skill2) ||
        (c.skill1 === stored.skill2 && c.skill2 === stored.skill1)
      );
      
      if (!exists) {
        allCorrelations.push({
          skill1: stored.skill1,
          skill2: stored.skill2,
          correlationStrength: parseFloat(stored.correlationStrength),
          correlationType: stored.correlationType as any,
          significance: stored.significance,
          studentCount: stored.studentCount,
          averageImpact: parseFloat(stored.averageImpact)
        });
      }
    }

    res.json({
      success: true,
      correlations: allCorrelations
    });

  } catch (error) {
    console.error('Error getting skill correlations:', error);
    res.status(500).json({ 
      success: false, 
      error: "Failed to get skill correlations" 
    });
  }
});

/**
 * POST /api/analytics/skill-correlations/analyze
 * Trigger AI analysis of skill correlations
 */
enhancedAnalyticsRouter.post("/skill-correlations/analyze", async (req, res) => {
  try {
    const { userIds } = req.body;
    
    const correlations = await aiAnalyticsService.analyzeSkillCorrelations(userIds);
    
    // Store new correlations in database
    for (const correlation of correlations) {
      try {
        await db.insert(skillCorrelations).values({
          skill1: correlation.skill1,
          skill2: correlation.skill2,
          correlationStrength: correlation.correlationStrength.toString(),
          correlationType: correlation.correlationType,
          significance: correlation.significance,
          studentCount: correlation.studentCount,
          averageImpact: correlation.averageImpact.toString(),
          dataTimeframe: 'last_90_days'
        });
      } catch (err) {
        // Ignore duplicates
        console.log('Skipping duplicate correlation:', correlation.skill1, correlation.skill2);
      }
    }

    res.json({
      success: true,
      correlations,
      message: `Analyzed ${correlations.length} skill correlations`
    });

  } catch (error) {
    console.error('Error analyzing skill correlations:', error);
    res.status(500).json({ 
      success: false, 
      error: "Failed to analyze skill correlations" 
    });
  }
});

// ====================================================================
// PERFORMANCE PATTERNS
// ====================================================================

/**
 * GET /api/analytics/performance-patterns/:userId
 * Get performance patterns for a specific student
 */
enhancedAnalyticsRouter.get("/performance-patterns/:userId", async (req, res) => {
  try {
    const userId = parseInt(req.params.userId);
    
    if (isNaN(userId)) {
      return res.status(400).json({ 
        success: false, 
        error: "Invalid user ID" 
      });
    }

    // Get AI-analyzed patterns
    const patterns = await aiAnalyticsService.analyzePerformancePatterns(userId);
    
    // Get stored patterns from database
    const storedPatterns = await db
      .select()
      .from(performancePatterns)
      .where(eq(performancePatterns.userId, userId))
      .orderBy(desc(performancePatterns.analysisEndDate));

    res.json({
      success: true,
      patterns,
      storedPatterns,
      summary: {
        totalSkills: patterns.length,
        improving: patterns.filter(p => p.patternType === 'improving').length,
        declining: patterns.filter(p => p.patternType === 'declining').length,
        stable: patterns.filter(p => p.patternType === 'stable').length,
        volatile: patterns.filter(p => p.patternType === 'volatile').length,
        plateaued: patterns.filter(p => p.patternType === 'plateaued').length
      }
    });

  } catch (error) {
    console.error('Error getting performance patterns:', error);
    res.status(500).json({ 
      success: false, 
      error: "Failed to get performance patterns" 
    });
  }
});

// ====================================================================
// ANALYTICS INSIGHTS
// ====================================================================

/**
 * GET /api/analytics/insights/:userId
 * Get personalized analytics insights for a student
 */
enhancedAnalyticsRouter.get("/insights/:userId", async (req, res) => {
  try {
    const userId = parseInt(req.params.userId);
    
    if (isNaN(userId)) {
      return res.status(400).json({ 
        success: false, 
        error: "Invalid user ID" 
      });
    }

    const insights = await db
      .select()
      .from(analyticsInsights)
      .where(and(
        eq(analyticsInsights.userId, userId),
        eq(analyticsInsights.dismissedAt, null as any)
      ))
      .orderBy(desc(analyticsInsights.createdAt));

    res.json({
      success: true,
      insights,
      categorized: {
        strengths: insights.filter(i => i.insightType === 'strength'),
        weaknesses: insights.filter(i => i.insightType === 'weakness'),
        opportunities: insights.filter(i => i.insightType === 'opportunity'),
        trends: insights.filter(i => i.insightType === 'trend'),
        predictions: insights.filter(i => i.insightType === 'prediction')
      }
    });

  } catch (error) {
    console.error('Error getting analytics insights:', error);
    res.status(500).json({ 
      success: false, 
      error: "Failed to get analytics insights" 
    });
  }
});

/**
 * PUT /api/analytics/insights/:insightId/dismiss
 * Dismiss an analytics insight
 */
enhancedAnalyticsRouter.put("/insights/:insightId/dismiss", async (req, res) => {
  try {
    const insightId = parseInt(req.params.insightId);
    
    const [updatedInsight] = await db
      .update(analyticsInsights)
      .set({
        dismissedAt: new Date(),
        updatedAt: new Date()
      })
      .where(eq(analyticsInsights.id, insightId))
      .returning();

    res.json({
      success: true,
      insight: updatedInsight
    });

  } catch (error) {
    console.error('Error dismissing insight:', error);
    res.status(500).json({ 
      success: false, 
      error: "Failed to dismiss insight" 
    });
  }
});

// ====================================================================
// COMPREHENSIVE ANALYTICS DASHBOARD
// ====================================================================

/**
 * GET /api/analytics/dashboard/:userId
 * Get comprehensive analytics dashboard data for a student
 */
enhancedAnalyticsRouter.get("/dashboard/:userId", async (req, res) => {
  try {
    const userId = parseInt(req.params.userId);
    
    if (isNaN(userId)) {
      return res.status(400).json({ 
        success: false, 
        error: "Invalid user ID" 
      });
    }

    // Get all analytics data in parallel
    const [
      problems,
      recommendations,
      patterns,
      insights,
      correlations
    ] = await Promise.all([
      aiAnalyticsService.detectLearningProblems(userId, 30),
      db.select().from(learningRecommendations)
        .where(eq(learningRecommendations.userId, userId))
        .orderBy(desc(learningRecommendations.createdAt))
        .limit(10),
      aiAnalyticsService.analyzePerformancePatterns(userId),
      db.select().from(analyticsInsights)
        .where(and(
          eq(analyticsInsights.userId, userId),
          eq(analyticsInsights.dismissedAt, null as any)
        ))
        .orderBy(desc(analyticsInsights.createdAt))
        .limit(15),
      aiAnalyticsService.analyzeSkillCorrelations()
    ]);

    res.json({
      success: true,
      dashboard: {
        problems: {
          data: problems,
          summary: {
            total: problems.length,
            critical: problems.filter(p => p.severity === 'critical').length,
            high: problems.filter(p => p.severity === 'high').length,
            actionRequired: problems.filter(p => p.severity === 'critical' || p.severity === 'high').length
          }
        },
        recommendations: {
          data: recommendations,
          summary: {
            total: recommendations.length,
            pending: recommendations.filter(r => r.status === 'pending').length,
            inProgress: recommendations.filter(r => r.status === 'in_progress').length,
            highPriority: recommendations.filter(r => r.priority === 'high').length
          }
        },
        performancePatterns: {
          data: patterns,
          summary: {
            improving: patterns.filter(p => p.patternType === 'improving').length,
            declining: patterns.filter(p => p.patternType === 'declining').length,
            needsAttention: patterns.filter(p => 
              p.patternType === 'declining' || p.patternType === 'plateaued'
            ).length
          }
        },
        insights: {
          data: insights,
          categorized: {
            strengths: insights.filter(i => i.insightType === 'strength'),
            weaknesses: insights.filter(i => i.insightType === 'weakness'),
            opportunities: insights.filter(i => i.insightType === 'opportunity')
          }
        },
        skillCorrelations: {
          data: correlations.slice(0, 10), // Top 10 strongest correlations
          strongPositive: correlations.filter(c => 
            c.correlationType === 'positive' && c.correlationStrength > 0.7
          ),
          strongNegative: correlations.filter(c => 
            c.correlationType === 'negative' && c.correlationStrength < -0.7
          )
        }
      }
    });

  } catch (error) {
    console.error('Error getting analytics dashboard:', error);
    res.status(500).json({ 
      success: false, 
      error: "Failed to get analytics dashboard" 
    });
  }
});

export { enhancedAnalyticsRouter };